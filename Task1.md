# Task 1
 ID | Titre | Description | DOD | Dépendances | US |Estimation (h/h) | Etat |Responsable
-------|-------------|-----|:-----------:|:--:|:---------------:|:----:|------|------
 T1-01 | Créer la release pour la fin du sprint 1.|Le fichier .war pour le serveur doit être généré, et le front doit être compilé en version production.|En faisant docker-compose up, l’application doit être lancée et accessible.| T0-00 |  | 2 | TODO |
T2-01|Créer la release du sprint 2|Créer la release pour la fin du sprint 2.<br> Le fichier .war pour le serveur doit être généré, et le front doit être compilé en version production.|En faisant docker-compose up, l’application doit être lancée et accessible.|T0-00| |2|TODO|
T3-01|Créer la release du sprint 3|Créer la release pour la fin du sprint 3. <br> Le fichier .war pour le serveur doit être généré, et le front doit être compilé en version production.|En faisant docker-compose up, l’application doit être lancée et accessible.|T0-00| |2|TODO|
T0-00|Mise en place du projet.|Créer le squelette de l’application. Créer dans le dossier *back* le projet java ee, créer dans le dossier *front* le projet angular. |Le dossier “back” est créé à la racine du fichier, contenant le code JEE.<br>Le dossier “front” est créé à la racine du fichier, contenant le code angular.| | |2|DONE|Robin
T1-03|Créer une section pour chaque partie du site.|Créer un composant pour chaque partie du site. <br>Il faut donc  un composant:<br> - Backlog<br> - Tasks<br> - Planification<br> - Sprint actif<br> - Tests<br> - Releases<br> - Documentation<br> - Statistics<br> - Le routage de l’application doit être réalisé. <br>‘/x’, x étant le nom de la partie en minuscule permet d’aller sur la section correspondante.|Les composant sont créés <br>Aller sur l'adresse ‘/x’ redirige sur la section x, x étant {backlog/tasks/planification/sprintActif/tests/releases/documentation/statistics}|T0-00|US-1, US-4|1|DOING|Alexis
T1-04|Créer la sidebar de navigation|Créer le composant “sidebar”. <br>La side bar contient un lien vers chaque partie du site, avec l’icon appropriée, et est situé sur le côté gauche de l’écran.<br>La sidebar doit avoir un icon en haut, qui lorsque l’on clique dessus, passe la sidebar en mode “replié”. <br>Seul les icons sont visibles, cliquer sur un icon redirige sur la partie du site correspondante.|Le composant sidebar est créé.<br>Cliquer sur le bouton d'extension réduit la barre de recherche si elle était étendue, l’expand si elle était réduite.<br>Cliquer sur un item redirige sur la section correspondante.|T1-03|US-1, US-4|4|TODO|
T1-03|Créer la section how-to|Créer le composant “how-to” contenant les instructions pour l’utilisation du site.<br/> Cette page contient une section pour chaque partie du site. <br/>Ces sections doivent contenir l’iframe pour afficher la vidéo d’explication.<br/>Créer le bouton en haut à droite redirigeant sur la page “how-to”. Quand l’utilisateur est dans une section spécifique, il doit être redirigé sur l’ancre correspondant à la section.|L’icon ‘how-to’ est présent sur chaque section du site.<br/> Cliquer dessus redirige sur la page how-to, sur la section correspondant à la “page” actuelle.<br/>How-to comporte bien une section pour chaque partie du site, avec les explications correspondantes.|US-1|2|TODO||
T1-13|Créer le model pour représenter un projet côté front.|Créer dans le dossier front/src/app/models le fichier project.model.ts, qui exporte la class Project.<br>La classe Project doit contenir tous les champs qui définissent un projet. Pour le moment : <br> - id: int <br>- name: string(50) <br>- description: string(500)|Le fichier est créé.<br>La classe Project est utilisable dans le reste de la partie front.|T0-00|US-2|1|TODO|
T1-14|Créer le service pour la gestion des projets côté front|Créer dans le dossier /front/src/app/services le service project.service.ts<br>Ce service communique avec l’endpoint ‘/api/projects’, il doit exposer les méthodes: <br>- getProjects()<br>-updateProject(Project)<br>- deleteProject(Project)<br>Ces méthodes doivent retourner un observable permettant de suivre l’évolution de la transaction.|Le service a été créé, et est injectable dans les autres composants.|T1-13,<br>T1-15|US-2|2|TODO|
T1-15|Créer l’endpoint pour la gestion des projets|Créer l’endpoint ‘/api/test’ qui expose les méthode GET, POST, PUT, DELETE.|L’endpoint doit être accessible et répondre correctement aux requêtes.|T0-00|US-2|4|TODO|
T1-19|Créer la DAOFactory, te son implémentation pour la bdd mysql|Créer l'interface `DAOFactory`, et son implémentation `SQLDAOFactory`. L'implémentation doit exposer la méthode static `getConnection()` permettant d'obtenir une connexion à la base de donnée.|L'interface et son implémentation son créées.<br>La connection avec la base de donnée est effective.|T0-00|US-2|2|DOING|Robin
T1-20|Créer le DAO pour les projets|Créer le bean `Project`, composé d'une String name et d'une String description.<br>Créer l'interface `ProjectDAO`, et son implémentation `SQLProjectDAO`.<br/>Ajouter dans l'interface `DAOFactory` la méthode `getProjectDAO` et l'implémenter `SQLDAOFactory`.<br>L'interface doit exposer les méthodes `Project getById(int id)`, `List<Project> getAll()`, `void addOne(Project project)`, `void updateOne(Project project)`. <br/>|Le bean est créé.<br>La méthode est ajouté dans l'interface DAOFactory, et l'implémentation retourne bien un `SQLProjectDAO`.<br>Les méthodes du DAO modifient correctement la base de donnée.|T1-19|US-2|2|TODO|Robin
T1-18|Créer la table projects dans la BDD|Créer la table Projects dans la base de donnée. Elle doit être composé des champ suivants:<br>- id (int, auto-increment, clef-primaire)<br>- name (string(50), unique)<br>-description(string(500))|La table doit être créé dans la base de donnée.|T0-00|US-2|1|DONE|Robin
T1-12|Créer le composant ProjectItem|Créer le composant projectItem, représentant un item de la liste des projets de la page correspondante.<br>Ce composant permet l’affichage d’un projet. Le titre et la description doivent être visible.<br>Il doit y avoir une barre de progression montrant le nombre de tâche réalisées (état done) sur le nombre de tâche total.<br>On doit également pouvoir visualiser le nombre d’us clôturées sur le nombre total d’us.|Le composant doit être créé.<br>Le composant doit pouvoir afficher correctement les données contenues dans un objet le la classe “Project”.|T1-13|US-2|2|TODO|
T1-17|Ajouter l’édition et la suppression dans ProjectItem|Ajouter deux boutons dans le composant ProjectItem, un pour la suppression, et un pour l’édition.<br>Cliquer sur le bouton d’édition doit ouvrire une popup dans laquelle ce trouve un formulaire proposant l’édition du titre ainsi que la description du projet.<br>Le bouton de suppression doit ouvrir une popup demandant confirmation pour la suppression.|Les deux boutons doivent être présents.<br>Cliquer sur “Editer” ouvre le formulaire d’édition. <br>Confirmer l’édition applique l’édition, abandonner ne l’applique pas.<br>Cliquer sur “Supprimer”|T1-12|US-2|4|TODO|
T2-06|Créer le composant ProjectList|Créer le composant ProjectList permettant de visualiser la liste de tous les projets.<br><br><br>Créer un bouton “Nouveau projet” en haut de la page proche de la barre de recherche. Ce bouton doit ouvrir un encart contenant un formulaire.<br><br>Ce formulaire est composé d’un input pour le titre du projet, et d’un textarea pour la description.<br>Un bouton valider doit permettre d’envoyer une requête de création au serveur, et un bouton abandonner doit permettre de faire disparaître l’encart, sans que le projet n'ait été créé.|Cliquer sur le bouton supprimer supprime le projet choisi.<br><br>Cliquer sur le bouton nouveau projet, crée un nouveau projet via un formulaire.|T0-00,<br>T1-12,<br>T1-14,<br>T1-13,<br>T1-17|US-2|1|TODO|
T1-05|Créer la barre de recherche dans le projet|Créer la barre de recherche dans le composant ProjectList.<br>Cette barre de recherche doit permettre la saisie de texte.<br> Un bouton submit doit permettre de masquer tous les projets ne correspondant pas aux termes de la recherche.|La barre de recherche est présente dans la section projet.<br><br>On peut entrer du texte dans l’input, et cliquer sur le bouton rechercher masque tous les projets ne correspondant pas aux termes de la recherche.|T2-06|US-3|3|TODO|
T2-07|Section documentation|Créer un menu de navigation sur la gauche de la section Documentation.<br>Créer un formulaire avec pour champ:<br>- un champ lien : une chaîne de caractères correspondant au lien à ajouter.<br><br>Au sein d’une section lien, créer un bouton “ajouter un lien” associé à ce formulaire, cliquer dessus envoie le formulaire.<br>Afficher la liste des liens dans cette section, chaque lien est cliquable.<br><br>Au sein d’une section texte, afficher un éditeur de texte pour pouvoir ajouter la documentation en format Text.<br><br>Créer un formulaire contenant:<br>- un champ Input : Text Area <br>Créer un bouton “ajouter post” lié à ce formulaire, permettant d’ajouter un post au format Markdown.<br>Afficher la liste des posts sous forme de lien cliquable: cliquer sur lien devra ouvrir un formulaire permettant de modifier le post.<br>Afficher chaque post de la liste sous cette liste.|Un menu de navigation est présent.<br><br>On peut ajouter des liens et cliquer dessus pour les ouvrir.<br><br>On peut ajouter de la documentation au format Text.<br><br>On peut ajouter des posts sous forme de liens cliquables, et visualiser chaque posts.|T1-03|US-22|4|TODO|
T1-06|Afficher les tests dans la section “Tests”|Dans le composants “tests”, il faut afficher tous les tests et leur état. <br>Les tests doivent être affichés les uns à la suite des autres. Il faut afficher le nom, la description, la dernière date d’exécution ou null si elle n’existe pas Le résultat du test doit être affiché, c’est à dire afficher “validé” en vert si c’est bon, “refusé” en rouge s’il n’est pas bon, ou “non-testé” si il n’y a pas de date d’exécution de test.<br><br>Des boutons ‘validé’ ou ‘échoué’ doivent mettre à jour l’état de du test.|Les tests d’un projet doivent être affichés.<br><br>Cliquer sur le bouton valider ou refuser met à jour l’état du test, c’est-à-dire qu’une requête est envoyée à l’api pour mettre à jour l’état, la date de modification|T1-03,<br> T1-11, <br>T1-16|US-23|2|TODO|
T1-16|Créer le model pour les tests|Créer le ficher ‘front/src/app/models/test.model.ts’ qui exporte la classe Test.|Le fichier est créé, et la classe Test est instanciable dans le reste de l’application.|T0-00|US-23|1|TODO|
T1-11|Créer le service pour la gestion des tests|Créer le service pour communiquer avec le serveur sur l’endpoint ‘/api/tests/’.<br><br>Il doit exposer les méthodes ‘getTests’, ‘postTest’, ‘updateTest’, qui retournent un observable.|Le service est créé et est infectable dans les autres composants.|T1-07,<br>T1-16|US-23|3|TODO|
T1-09|Affiché l’indicateur d’avancement des tâches|Dans la section tests, créer une barre d’avancement montrant le nombre de tests validés sur le nombre de tests totaux. <br>Elle doit être affichée sous le titre de la page.|La barre d’avancement est affichée.<br><br>L’avancement doit correspondre à l’avancement réel de l’exécution des tests.|T1-07|US-23|2|TODO|
T1-07|Créer le endpoint pour la gestion des tests|Expose l’api de gestion des tests sur “/api/test”. Les opérations GET, POST, PUT doivent être implémentées.|L’endpoint doit être accessible et répondre correctement aux requêtes.|T1-08|US-23|4|TODO|
T1-21|Créer le DAO pour les tests|Créer le bean `Test`, composé d'une String name, d'une String description, d'un booléan state, d'une String lastExecution et d'un state pouvant prendre les valeurs *validated*, *refused*, *not executed*.<br>Créer l'interface `TestDAO`, et son implémentation `SQLTestDAO`.<br/>L'interface doit exposer les méthodes `Test getById(int id)`, `List<Test> getAll()`, `void addOne(Test test)`, `void updateOne(Test test)`. <br>Ajouter dans l'interface `DAOFactory` la méthode `getTestDAO` et l'implémenter `SQLDAOFactory`.|Le bean est créé.<br/>La méthode est ajouté dans l'interface DAOFactory, et l'implémentation retourne bien un `SQLTestDAO`.<br/>Les méthodes du DAO modifient correctement la base de donnée.|T1-19|US-23|2|TODO|Robin
T1-08|Créer la structure pour stocker les tests dans la BDD|Créer la table Tests. Elle est composé :<br>- id (int, auto-increment, primary-key)<br>- name (string(50), unique)<br>- description (string(500))<br>- lastExecution (timestamp, auto-update, NULL)<br>- state(enum(validé, refusé, non-testé(default))|La table doit être créer dans la bdd|T0-00|US-23|1|DONE|Robin
T2-09|Création bouton d’importation.|Créer un bouton Importer permettant d’ouvrir l’explorateur de fichiers pour choisir un fichier récapitulatif de tests au format .json.<br>Faire une requête PUT sur ‘/api/tests’ en spécifiant le fichier json.|On peut importer un fichier de tests par l’interface graphique ou par requêtes.<br><br>L’état des tests sur le serveur est mis à jour avec les données si elles sont correctes.|T1-07,<br> T1-10|US-24|1|TODO|
T1-10|Spécifier le format json pour les tests|Dans la section “how-to”, dans la partie des tests, ajouter la partie sur le format à respecter pour ajouter automatiquement des tests. Ce format devra être : <br>[<br>    &nbsp;&nbsp;&nbsp;&nbsp;{<br>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: …,<br>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description: ....,<br>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastExecution: ….,<br>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: ….,<br>    &nbsp;&nbsp;&nbsp;&nbsp;},<br>]|La spécification est visible dans la partie tests de la section “how-to”|T1-02|US-24|1|TODO|
